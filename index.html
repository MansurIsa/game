<!doctype html>
<html lang="az">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Train Runner</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#8fd3ff}
    canvas{display:block}

    /* Video kimi top HUD */
    #topHud{
      position:fixed; left:0; right:0; top:0;
      height:64px; pointer-events:none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:#0b1220;
    }
    #barWrap{
      position:absolute; left:18px; right:18px; top:10px; height:10px;
      border-radius:999px;
      border:2px solid rgba(0,0,0,.25);
      background:rgba(255,255,255,.45);
      overflow:hidden;
      box-shadow: 0 6px 16px rgba(0,0,0,.12);
    }
    #barFill{
      height:100%; width:18%;
      background:linear-gradient(90deg,#ffd34d,#ff9f1c);
      border-radius:999px;
    }
    #hudRow{
      position:absolute; left:18px; right:18px; top:28px;
      display:flex; justify-content:space-between; align-items:center;
      font-weight:700; font-size:12px;
      text-shadow: 0 1px 0 rgba(255,255,255,.6);
    }
    #centerHint{
      position:absolute; left:50%; transform:translateX(-50%);
      top:22px; text-align:center; font-weight:900;
      letter-spacing:.6px;
    }
    #hintCircle{
      width:34px; height:34px; border-radius:50%;
      background:rgba(255,255,255,.55);
      border:2px solid rgba(0,0,0,.18);
      display:flex; align-items:center; justify-content:center;
      margin:0 auto 2px auto;
    }
    #hintTxt{ font-size:10px; opacity:.9; }

    /* speed lines overlay (video kimi) */
    #fx{
      position:fixed; inset:0; pointer-events:none;
      background:
        radial-gradient(ellipse at center, rgba(255,255,255,0) 0%, rgba(255,255,255,0) 55%, rgba(255,255,255,.08) 100%);
      mix-blend-mode: screen;
    }
    .streak{
      position:absolute; width:2px; height:120px;
      background:rgba(255,255,255,.85);
      filter: blur(.2px);
      transform: skewX(-18deg);
      opacity:.9;
    }

    #btnAudio{
      position:fixed; right:12px; bottom:12px;
      pointer-events:auto;
      cursor:pointer; user-select:none;
      display:inline-flex; gap:8px; align-items:center;
      padding:10px 12px; border-radius:12px;
      background:rgba(255,255,255,.75);
      border:1px solid rgba(0,0,0,.12);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      box-shadow: 0 8px 24px rgba(0,0,0,.12);
    }
    #msg{
      position:fixed; left:12px; bottom:12px;
      padding:10px 12px; border-radius:12px;
      background:rgba(255,255,255,.55);
      border:1px solid rgba(0,0,0,.10);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size:13px; color:#0b1220;
      box-shadow: 0 8px 24px rgba(0,0,0,.12);
      pointer-events:none;
      max-width: 66vw;
    }
  </style>
</head>
<body>
  <div id="topHud">
    <div id="barWrap"><div id="barFill"></div></div>
    <div id="hudRow">
      <div id="lvl">LEVEL 1</div>
      <div id="goal">GOAL: 2200m</div>
    </div>

    <div id="centerHint">
      <div id="hintCircle">‚¨ÜÔ∏è</div>
      <div id="hintTxt">JUMP</div>
    </div>
  </div>

  <div id="fx"></div>

  <div id="msg">‚Üê/‚Üí (A/D) lane ‚Ä¢ ‚Üë/Space jump ‚Ä¢ Mobil: swipe left/right/up ‚Ä¢ Qatarƒ±n √ºst√ºn…ô d√º≈ü, √ºst√ºnd…ô qa√ß.</div>
  <div id="btnAudio">üîä <span id="audioState">S…ôsi aktiv et</span></div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

/* --------------------------- FX streaks --------------------------- */
const fx = document.getElementById("fx");
const streaks=[];
function makeStreak(){
  const s=document.createElement("div");
  s.className="streak";
  s.style.left=(Math.random()*100)+"%";
  s.style.top=(-140-Math.random()*240)+"px";
  s.style.height=(80+Math.random()*160)+"px";
  s.style.opacity=(0.35+Math.random()*0.55);
  fx.appendChild(s);
  streaks.push(s);
}
for(let i=0;i<18;i++) makeStreak();
function updateStreaks(speed){
  for(const s of streaks){
    const top=parseFloat(s.style.top);
    const ny=top + (7 + speed*0.35);
    s.style.top = ny+"px";
    if(ny>innerHeight+200){
      s.style.left=(Math.random()*100)+"%";
      s.style.top=(-200-Math.random()*240)+"px";
      s.style.height=(80+Math.random()*160)+"px";
      s.style.opacity=(0.35+Math.random()*0.55);
    }
  }
}

/* --------------------------- Renderer/Scene --------------------------- */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x8fd3ff, 28, 170);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 260);
camera.position.set(0, 5.2, 11);

scene.add(new THREE.HemisphereLight(0xffffff, 0x8b6a2a, 0.9));
const sun = new THREE.DirectionalLight(0xffffff, 0.9);
sun.position.set(14, 18, 10);
scene.add(sun);

/* --------------------------- Audio (BG loop) --------------------------- */
let audioCtx=null, audioEnabled=false;
let bg=null;
function ensureAudio(){
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state==="suspended") audioCtx.resume();
  audioEnabled=true;
  document.getElementById("audioState").textContent="S…ôs aktivdir";
  startBG();
}
function startBG(){
  if(!audioEnabled || !audioCtx || bg) return;

  // rumble: low sine + noise filtered
  const rum = audioCtx.createOscillator();
  rum.type="sine";
  rum.frequency.value=42;

  const rumG = audioCtx.createGain();
  rumG.gain.value=0.05;

  const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate*1.5, audioCtx.sampleRate);
  const d = noiseBuf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.18;

  const noise = audioCtx.createBufferSource();
  noise.buffer=noiseBuf;
  noise.loop=true;

  const bp = audioCtx.createBiquadFilter();
  bp.type="bandpass";
  bp.frequency.value=280;
  bp.Q.value=0.55;

  const nG = audioCtx.createGain();
  nG.gain.value=0.06;

  // tiny lfo movement
  const lfo = audioCtx.createOscillator();
  lfo.type="sine";
  lfo.frequency.value=0.14;
  const lfoG = audioCtx.createGain();
  lfoG.gain.value=120;
  lfo.connect(lfoG).connect(bp.frequency);

  rum.connect(rumG).connect(audioCtx.destination);
  noise.connect(bp).connect(nG).connect(audioCtx.destination);

  rum.start();
  noise.start();
  lfo.start();

  bg={rum, rumG, noise, bp, nG, lfo};
}
function sfxJump(){
  if(!audioEnabled || !audioCtx) return;
  const t=audioCtx.currentTime;
  const o=audioCtx.createOscillator();
  const g=audioCtx.createGain();
  o.type="square";
  o.frequency.setValueAtTime(720,t);
  g.gain.setValueAtTime(0.0001,t);
  g.gain.exponentialRampToValueAtTime(0.10,t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001,t+0.12);
  o.connect(g).connect(audioCtx.destination);
  o.start(t); o.stop(t+0.14);
}
document.getElementById("btnAudio").addEventListener("pointerdown",(e)=>{ e.preventDefault(); ensureAudio(); });

/* --------------------------- World: desert + tracks --------------------------- */
const world = new THREE.Group();
scene.add(world);

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(140, 520),
  new THREE.MeshStandardMaterial({ color:0xf3d998, roughness:0.98, metalness:0.0 })
);
ground.rotation.x=-Math.PI/2;
ground.position.set(0,-0.01,-220);
world.add(ground);

// low-poly pyramids
const pyrMat = new THREE.MeshStandardMaterial({ color:0xf0c978, roughness:0.98 });
for(let i=0;i<9;i++){
  const p = new THREE.Mesh(new THREE.ConeGeometry(6+Math.random()*6, 6+Math.random()*6, 4), pyrMat);
  p.position.set((Math.random()<0.5?-1:1)*(18+Math.random()*45), 3, -80-Math.random()*360);
  p.rotation.y=Math.random()*Math.PI;
  world.add(p);
}
// cactus
const cactusMat = new THREE.MeshStandardMaterial({ color:0x2f8d57, roughness:0.9 });
for(let i=0;i<38;i++){
  const c = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.16,1.2,8), cactusMat);
  c.position.set((Math.random()<0.5?-1:1)*(8+Math.random()*28), 0.6, -30-Math.random()*420);
  world.add(c);
}

// 3 lanes (like video)
const LANES=[-3.2,0,3.2];
const bed = new THREE.Mesh(
  new THREE.BoxGeometry(12, 0.22, 520),
  new THREE.MeshStandardMaterial({ color:0x2b2f36, roughness:0.95 })
);
bed.position.set(0,0.06,-220);
world.add(bed);

// blue center line like video
const blueLine = new THREE.Mesh(
  new THREE.BoxGeometry(0.05, 0.03, 520),
  new THREE.MeshStandardMaterial({ color:0x1aa8ff, roughness:0.6, metalness:0.0 })
);
blueLine.position.set(0,0.16,-220);
world.add(blueLine);

// rails + sleepers
const railMat = new THREE.MeshStandardMaterial({ color:0x4b4f56, roughness:0.55, metalness:0.2 });
const sleeperMat = new THREE.MeshStandardMaterial({ color:0x5a3b2a, roughness:0.9 });

function addRailsForLane(x){
  const r1=new THREE.Mesh(new THREE.BoxGeometry(0.10,0.10,520), railMat);
  const r2=new THREE.Mesh(new THREE.BoxGeometry(0.10,0.10,520), railMat);
  r1.position.set(x-0.55,0.16,-220);
  r2.position.set(x+0.55,0.16,-220);
  world.add(r1,r2);
}
LANES.forEach(addRailsForLane);

const sleeperGeo=new THREE.BoxGeometry(1.45,0.08,0.26);
const sleeperCount=380;
const sleepers=new THREE.InstancedMesh(sleeperGeo, sleeperMat, sleeperCount);
sleepers.frustumCulled=false;
const M=new THREE.Matrix4();
for(let i=0;i<sleeperCount;i++){
  const z=-10-i*1.35;
  M.makeTranslation(0,0.10,z);
  sleepers.setMatrixAt(i,M);
}
world.add(sleepers);

/* --------------------------- Trains (long cars) --------------------------- */
const trains=[];
const trainBodyMat=new THREE.MeshStandardMaterial({ color:0x4f6d7a, roughness:0.75 });
const trainRoofMat=new THREE.MeshStandardMaterial({ color:0x30424a, roughness:0.85 });
const trainWinMat =new THREE.MeshStandardMaterial({ color:0xa6e1ff, roughness:0.35, metalness:0.10 });

function makeTrain(){
  const g=new THREE.Group();

  const body=new THREE.Mesh(new THREE.BoxGeometry(2.8, 2.1, 13.0), trainBodyMat);
  body.position.y=1.05; g.add(body);

  const roof=new THREE.Mesh(new THREE.BoxGeometry(2.9, 0.26, 13.1), trainRoofMat);
  roof.position.y=2.25; g.add(roof);

  const win=new THREE.Mesh(new THREE.BoxGeometry(2.82, 0.62, 9.0), trainWinMat);
  win.position.set(0,1.35,0); g.add(win);

  // front nose
  const nose=new THREE.Mesh(new THREE.BoxGeometry(2.7, 1.7, 0.40),
    new THREE.MeshStandardMaterial({ color:0x232a31, roughness:0.95 }));
  nose.position.set(0,0.95,6.55); g.add(nose);

  g.userData = {
    halfZ: 13.0/2,
    topY: 2.25 + 0.26/2
  };
  return g;
}

let nextTrainZ=-32;
function spawnTrain(){
  const lane=Math.floor(Math.random()*3);
  const t=makeTrain();
  t.position.set(LANES[lane], 0, nextTrainZ);
  world.add(t);
  trains.push({
    mesh:t, lane,
    speedMul: 0.85 + Math.random()*0.25,
    removed:false
  });
  nextTrainZ -= (30 + Math.random()*22);
}
for(let i=0;i<10;i++) spawnTrain();

/* --------------------------- Player (invisible runner) --------------------------- */
const player={
  lane:1,
  x:LANES[1],
  y:1.05,
  radius:0.45,
  vy:0,
  isJumping:false,
  onTrain:null, // ref to train obj if standing on roof
  gravity:21.0,
  jumpVel:8.4
};

function laneX(i){ return LANES[i]; }
function overlapTrain(train){
  // player at z=0
  const dz=Math.abs(train.mesh.position.z - 0);
  return dz < (train.mesh.userData.halfZ + 0.65);
}
function trainTopY(train){ return train.mesh.userData.topY; }

/* if lane change while on train:
   - if adjacent lane has a train underfoot at that moment -> switch to it
   - else -> fall (player.onTrain=null, start falling)
*/
function findTrainUnderPlayer(lane){
  for(const t of trains){
    if(t.removed) continue;
    if(t.lane!==lane) continue;
    if(!overlapTrain(t)) continue;
    return t;
  }
  return null;
}

/* --------------------------- HUD progress like video --------------------------- */
let level = 1;
let goalM = 2200;
let dist = 0;
const barFill=document.getElementById("barFill");
const lvlEl=document.getElementById("lvl");
const goalEl=document.getElementById("goal");
lvlEl.textContent = `LEVEL ${level}`;
goalEl.textContent = `GOAL: ${goalM}m`;

const hintCircle=document.getElementById("hintCircle");
const hintTxt=document.getElementById("hintTxt");
let hintTimer=2.5; // show at start

function setHint(txt, icon){
  hintTxt.textContent = txt;
  hintCircle.textContent = icon;
  hintTimer = 1.2;
}

/* --------------------------- Controls --------------------------- */
let alive=true;
const msgEl=document.getElementById("msg");

function moveLane(dir){
  if(!alive) return;
  const oldLane=player.lane;
  player.lane = Math.max(0, Math.min(2, player.lane+dir));
  if(player.lane!==oldLane) setHint(dir>0?"RIGHT":"LEFT", dir>0?"‚û°Ô∏è":"‚¨ÖÔ∏è");

  // if on a train, check if still supported
  if(player.onTrain){
    const under = findTrainUnderPlayer(player.lane);
    if(under){
      player.onTrain = under;
    }else{
      // start falling from roof (no jump impulse)
      player.onTrain = null;
      player.isJumping = true;
      player.vy = 0;
    }
  }
}

function jump(){
  if(!alive) return;
  if(player.isJumping) return;
  player.isJumping=true;
  player.vy=player.jumpVel;
  player.onTrain=null;
  setHint("JUMP","‚¨ÜÔ∏è");
  sfxJump();
}

addEventListener("keydown",(e)=>{
  if(e.code==="ArrowLeft"||e.code==="KeyA") moveLane(-1);
  if(e.code==="ArrowRight"||e.code==="KeyD") moveLane(1);
  if(e.code==="ArrowUp"||e.code==="Space"){ ensureAudio(); jump(); }
  if(!alive && (e.code==="Enter"||e.code==="Space")) reset();
});

addEventListener("pointerdown",()=>{ if(!alive) reset(); }, {passive:true});

// swipe
let sx=null, sy=null;
addEventListener("pointerdown",(e)=>{ sx=e.clientX; sy=e.clientY; }, {passive:true});
addEventListener("pointerup",(e)=>{
  if(sx==null) return;
  const dx=e.clientX-sx, dy=e.clientY-sy;
  sx=null; sy=null;
  if(Math.abs(dx)<20 && Math.abs(dy)<20) return;
  if(Math.abs(dx)>Math.abs(dy)) moveLane(dx>0?1:-1);
  else if(dy<0){ ensureAudio(); jump(); }
},{passive:true});

/* --------------------------- Game loop --------------------------- */
let baseSpeed=16.0;
let last=performance.now();

function gameOver(){
  alive=false;
  msgEl.textContent="Uduzdun. Ekrana klik et -> restart";
}
function reset(){
  alive=true;
  msgEl.textContent="‚Üê/‚Üí lane ‚Ä¢ ‚Üë/Space jump ‚Ä¢ Qatarƒ±n √ºst√ºn…ô d√º≈ü, √ºst√ºnd…ô qa√ß.";
  player.lane=1; player.x=LANES[1]; player.y=1.05; player.vy=0;
  player.isJumping=false; player.onTrain=null;
  baseSpeed=16.0;
  dist=0;
  // trains reset
  for(const t of trains) world.remove(t.mesh);
  trains.length=0;
  nextTrainZ=-32;
  for(let i=0;i<10;i++) spawnTrain();
  setHint("JUMP","‚¨ÜÔ∏è");
}

function updateCamera(dt){
  const targetX = laneX(player.lane);
  player.x += (targetX - player.x)*0.18;

  camera.position.x += (player.x - camera.position.x)*0.10;
  const desiredY = player.y + 4.2;
  camera.position.y += (desiredY - camera.position.y)*0.08;
  camera.lookAt(player.x, player.y+0.2, 0);
}

function step(dt){
  // speed ramps like video
  baseSpeed += 0.35*dt;
  const speed = baseSpeed;

  // distance / progress
  dist += speed*dt * 6.5; // scale to meters feel
  const prog = Math.min(1, dist/goalM);
  barFill.style.width = (8 + prog*92) + "%";

  // hint fade
  if(hintTimer>0){
    hintTimer-=dt;
    document.getElementById("centerHint").style.opacity = "1";
  }else{
    document.getElementById("centerHint").style.opacity = "0";
  }

  // jump/fall physics
  const groundY = 1.05;

  if(player.isJumping){
    player.vy -= player.gravity*dt;
    player.y += player.vy*dt;

    // landing check on train roofs (when falling)
    if(player.vy<=0){
      let landed=false;
      const under = findTrainUnderPlayer(player.lane);
      if(under){
        const top = trainTopY(under);
        if(player.y - player.radius <= top + 0.08 && player.y > top){
          player.y = top + player.radius;
          player.vy = 0;
          player.isJumping=false;
          player.onTrain=under;
          landed=true;
        }
      }
      // land on ground
      if(!landed && player.y<=groundY){
        player.y=groundY;
        player.vy=0;
        player.isJumping=false;
        player.onTrain=null;
      }
    }
  }else{
    // standing: keep attached to train if still overlapping
    if(player.onTrain && !player.onTrain.removed && overlapTrain(player.onTrain) && player.onTrain.lane===player.lane){
      const top=trainTopY(player.onTrain);
      player.y += (top + player.radius - player.y)*0.25;
    }else{
      player.onTrain=null;
      player.y += (groundY - player.y)*0.18;
    }
  }

  // move trains towards player
  for(const t of trains){
    if(t.removed) continue;
    const v = speed * t.speedMul;
    t.mesh.position.z += v*dt;

    // collision if train overlaps and player not on roof
    if(alive && t.lane===player.lane && overlapTrain(t)){
      const top=trainTopY(t);
      const safeOnRoof = (player.y - player.radius) >= (top - 0.12);
      if(!safeOnRoof) gameOver();
    }

    // remove after passing
    if(t.mesh.position.z > camera.position.z + 18){
      t.removed=true;
      world.remove(t.mesh);
    }
  }

  // spawn more trains ahead
  const farthestZ = trains.reduce((minZ, t)=>Math.min(minZ, t.mesh.position.z), 0);
  while(nextTrainZ > farthestZ - 140) spawnTrain();

  // compact array
  for(let i=trains.length-1;i>=0;i--) if(trains[i].removed) trains.splice(i,1);

  updateStreaks(speed);
  updateCamera(dt);
}

function animate(now){
  const dt = Math.min(0.033, (now-last)/1000);
  last=now;
  if(alive) step(dt);
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
